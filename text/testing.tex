\section{Экспериментальный анализ и тестирование}

\subsection{Цели тестирования}

Целью экспериментального анализа является:
\begin{itemize}
    \item Проверка корректности работы сборщика мусора в различных сценариях: однопоточные и многопоточные аллокации, работа с корнями, циклические ссылки, realloc и пр.
    \item Измерение производительности: скорость аллокации, время сборки, эффективность автоматической и ручной сборки.
    \item Анализ влияния различных эвристик и параметров (байтовые и количественные пороги, частота обновления, всплески аллокаций).
    \item Демонстрация масштабируемости и многопоточности.
\end{itemize}

\subsection{Подход к тестированию}

Тестирование разделено на два направления:

\begin{enumerate}[label=\arabic*.]
    \item \textbf{Юнит-тесты}, реализованные на базе \texttt{Google Test}. Охватывают:
    \begin{itemize}
        \item простую аллокацию и освобождение;
        \item сохранение объектов, достижимых через корни;
        \item корректную работу при realloc и массивных выделениях;
        \item сборку циклических ссылок;
        \item автоматическую и ручную сборку в многопоточной среде;
        \item изменение параметров GC во время работы.
    \end{itemize}

    \item \textbf{Бенчмарки}, реализованные через \texttt{Google Benchmark}, направленные на измерение времени аллокации, сборки и общего throughput.
\end{enumerate}


\subsection{Результаты производительности}

Ниже приведены результаты запусков различных тестов и нагрузочных сценариев.

\subsubsection*{Realloc-тест}

\begin{itemize}
    \item 100 последовательных \texttt{realloc()} на одном объекте (64–128 байт).
    \item Время на итерацию: $43.4\,\mu s$ (CPU time), $82.3\,\mu s$ (реальное).
    \item Скорость: $2.3 \cdot 10^6$ аллокаций/с.
\end{itemize}

\subsubsection*{Drop 5\%}

\begin{itemize}
    \item 10\,000 объектов, каждая сборка «теряет» 5\% указателей.
    \item Время сборки: $28.6\,\mu s$ CPU, $35.0\,\mu s$ wall-time.
    \item Скорость обработки: $\sim$350 млн объектов/сек.
\end{itemize}

\subsubsection*{DropProbability Sweep (от 0\% до 100\%)}

\begin{table}[ht]
    \caption{Результаты теста GC с различной вероятностью утери ссылок (DropProbability). Замерено время полной сборки мусора и количество обработанных элементов в секунду.}
    \label{table:drop_probability}
    \footnotesize
    \centering
    \begin{tabular}{lrr}
        \toprule
        \textbf{Drop, \%} & \textbf{Время (мкс)} & \textbf{Пропускная способность (items/sec)} \\
        \midrule
        0\%   & 1854 & 5.52M \\
        5\%   & 2411 & 4.18M \\
        15\%  & 2377 & 4.25M \\
        30\%  & 2129 & 4.63M \\
        50\%  & 1922 & 5.34M \\
        70\%  & 1556 & 6.69M \\
        100\% & 420  & 23.55M \\
        \bottomrule
    \end{tabular}
\end{table}

\textbf{Вывод:} по мере увеличения вероятности удаления мусора, время сборки уменьшается, а throughput увеличивается — это ожидаемо, так как остаётся меньше достижимых объектов, и проход по heap упрощается.

\subsubsection*{Сложные действия с памятью (SimulateActions)}

\begin{itemize}
    \item Смоделированы 200 случайных действий над 10\,000 объектами.
    \item Время: $2581\,\mu s$ CPU, $2599\,\mu s$ wall-time.
    \item Тест охватывает чтение, запись, удаление, перезапись указателей.
\end{itemize}

\subsubsection*{Автоматическая сборка на больших массивах}

Тестирование сборки при включённом авто-GC:

\begin{table}[ht]
    \caption{Производительность авто-GC при различных размерах и количестве объектов. Замерено общее время на цикл и число итераций в секунду.}
    \label{table:auto_gc}
    \footnotesize
    \centering
    \begin{tabular}{lrr}
        \toprule
        \textbf{Размер задачи} & \textbf{Время (мкс)} & \textbf{Итераций в секунду} \\
        \midrule
        1\,000\,000 × 32–64 байт   & 24\,632 & 29 \\
        1\,000\,000 × 64–512 байт  & 102\,282 & 5 \\
        500\,000 × 1–4 КБ          & 56\,447 & 11 \\
        100\,000 × 1–8 КБ          & 42\,225 & 14 \\
        \bottomrule
    \end{tabular}
\end{table}

\noindent
Таблица~\ref{table:auto_gc} демонстрирует, что сборщик мусора адекватно масштабируется при росте как объёма, так и числа объектов. Более крупные объекты увеличивают суммарное время, но не приводят к деградации системы или зависаниям.


\subsection{Многопоточность и безопасность}

\begin{itemize}
    \item Проверены сценарии с 8 потоками, одновременно выполняющими аллокации и сборки.
    \item Поддерживается регистрация/удаление потоков во время работы.
    \item Потоки корректно реагируют на \texttt{StopTheWorld} через \texttt{gc\_safepoint()}.
\end{itemize}

Все тесты завершились успешно, без утечек памяти и гонок. Тестирование было проведено с разными санитайзерами (\texttt{address, thread, undefined, valgrind})


\subsection{Выводы}

Эксперименты показали:

\begin{itemize}
    \item Высокую производительность и масштабируемость при росте числа объектов.
    \item Эффективную работу авто-GC при разных сценариях.
    \item Корректность и стабильность даже при интенсивной многопоточной нагрузке.
    \item Полное покрытие типичных и сложных ситуаций: циклические ссылки, массивы,\\ realloc, потоковые гонки.
\end{itemize}

Таким образом, реализация сборщика мусора показывает достойные характеристики как в тестах на корректность, так и в производительных нагрузках.
