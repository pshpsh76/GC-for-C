\section{Обзор литературы}

\subsection{Основные идеи сборки мусора}

Существуют несколько фундаментальных идей, лежащих в основе современных сборщиков мусора. Эти идеи определяют, \textbf{как именно} GC определяет «ненужные» объекты и освобождает память. Идеи ниже были подробнее описаны в книге~\cite{gc-handbook}

\subsubsection{Подсчет ссылок (Reference Counting, RC)}

Одна из простейших идей управления памятью — \textbf{подсчет ссылок (Reference Counting, RC)}. У каждого объекта хранится счётчик активных ссылок. Когда создается новая ссылка, счетчик увеличивается, а при удалении ссылки — уменьшается. Если счетчик достигает нуля, объект удаляется, ресурсы освобождаются

Пример использования Reference Counting можно найти в \textbf{C++}, где умные указатели \texttt{shared\_ptr} реализуют этот подход на уровне стандартной библиотеки, а также в \textbf{Rust}, где есть \texttt{Rc}, и потокобезопасный \texttt{Arc}.

\textbf{Преимущества:}
\begin{enumerate}[label=\arabic*.]
    \item Простая реализация
    \item Освобождение памяти происходит \textbf{немедленно}, как только объект становится ненужным.
    \item Подходит для сценариев с предсказуемым управлением памятью.
    \item Может быть использован в средах с ограниченными ресурсами, так как не требует сложных глобальных обходов памяти.
\end{enumerate}

\textbf{Недостатки:}
\begin{enumerate}[label=\arabic*.]
    \item Управление счетчиком требует \textbf{дополнительных затрат CPU}, которые становятся значительными, если в программе много объектов, происходит много операций присваивания переменных, а также большой оверхед на короткоживущих объектах. Любые Read, Write операции с объектами требуют модификаций Rc. Кроме того, происходит косвенное замедление других операций (так как например нужные значения уходят из кэшей процессора, меняясь на адреса в памяти Rc).
    \item Не может автоматически очистить \textbf{циклические зависимости}, когда два объекта ссылаются друг на друга.
    \item Для эффективной работы, а также, чтобы сохранять исходную структуру пользовательских типов данных требует \textbf{глубокой интеграции с компилятором/интерпретатором}
    \item В многопоточной среде требуется синхронизация доступа к счетчику, что может приводить к задержкам (например, \textbf{использование атомарных операций или мьютексов}).
    \item \textbf{Не освобождает недостижимые, но еще используемые объекты}: в RC объект освобождается только когда его счетчик ссылок становится равным нулю. Однако объект может оставаться доступным (например, в коллекциях или кэше), даже если он больше не нужен.
    \item Размер каждого объекта должен быть увеличен на \textbf{8 байтов} для хранения счётчика
\end{enumerate}

\subsubsection{Почему Reference Counting не заменяет Tracing GC?}

Хотя в некоторых языках (например, C++) можно использовать слабые ссылки (\textit{weak references}) для разрыва циклических зависимостей, \textbf{это не делает Reference Counting полноценной заменой Tracing GC}. Кроме недостатков, описанных выше:
\textbf{Не освобождает сложные структуры данных автоматически}: в RC программист должен сам следить за корректным управлением памятью. Tracing GC автоматически очищает даже сложные графы объектов. То есть управление памяти перестаёт быть полностью автоматическим.
Таким образом, \textbf{Reference Counting} может быть лишь частью GC.



\subsubsection{Отслеживание достижимости (Tracing Garbage Collection) и Mark-Sweep}

Вместо явного подсчета ссылок можно использовать другую идею: \textbf{не важно, сколько у объекта ссылок, важно — достижим ли он от корневых объектов (GC roots)}. Эта концепция лежит в основе \textbf{Tracing GC}.

Основной механизм, использующий эту идею, — это \textbf{Mark-Sweep}:
\begin{enumerate}[label=\arabic*.]
    \item На первом этапе GC проходит по всем объектам, начиная от «корневых» (глобальные переменные, стек вызовов, регистры CPU) и, проходя рекурсивно по графу связей объектов, \textbf{помечает} все достижимые объекты (\textbf{стадия Mark}). Проход по графу объекту - называется Tracing, отсюда и Tracing GC.
    \item Затем все непомеченные объекты удаляются (\textbf{стадия Sweep}).
\end{enumerate}

\textbf{Преимущества:}
\begin{enumerate}[label=\arabic*.]
    \item Автоматически очищает \textbf{циклы} (в отличие от Reference Counting).
    \item Не перемещает объекты, \textbf{указатели не инвалидируются}
    \item Нет оверхеда на операции Read, Write
    \item Маленький оверхед по памяти по сравнению с RC. Если вспомнить, что в современных системах используются только первые 48 бит из 64 в указателе, то mark bit можно зашивать в оставшиеся 16. Тогда вообще нет оверхеда.
    \item Не требует никакой информации о типах и структуре объектов, то есть не должен работать вместе с компилятором/интерпретатором, может быть отдельным модулем.
\end{enumerate}

\textbf{Недостатки:}
\begin{enumerate}[label=\arabic*.]
    \item Остановка программы на время очистки (\textit{Stop-the-World}).
    \item В многопоточном случае проблема Stop-the-World усугубляется.
    \item Надо буквально парсить Heap, чтобы находить живущие объекты. А значит время работы пропорционально размеру Heap.
    \item Из-за того что не перемещает объекты, то вероятность фрагментации памяти повышается, поэтому вместе с таким GC должен работать продвинутый аллокатор.
\end{enumerate}

\subsubsection{Mark-Compact}

Чтобы решить проблему фрагментации памяти после Mark-Sweep, используется идея \textbf{Mark-Compact}. Вместо простого удаления объектов GC \textbf{перемещает} оставшиеся объекты, чтобы устранить пробелы в памяти.

\textbf{Преимущества:}
\begin{enumerate}[label=\arabic*.]
    \item Исключает фрагментацию памяти. Сильно ускоряется аллокации.
    \item Обеспечивает лучшее кеширование данных CPU, так как данные расположены рядом
\end{enumerate}

\textbf{Недостатки:}
\begin{enumerate}[label=\arabic*.]
    \item Дополнительные затраты на перемещение объектов.
    \item Хуже throughput, чем у mark-sweep, так как требует несколько проходов по heap
    \item Требуется интеграция с компилятором/интерпрератором/аллокатором, так как надо знать много доп. информации про перемещаемые участки памяти, надо обновлять указатели, которые перестали быть действительными, надо знать когда выгодно запускать.
    \item Долгоживущие объекты являются bottleneck этого алгоритма, так как тратятся ресурсы на постоянное копирование таких объектов
    \item Чтобы сделать время работы приемлемым, то может не выполняться стадия compact для мелких частей, тем самым фрагментацию нельзя избежать полностью
    \item Сохраняются недостатки 1-3 mark-sweep
\end{enumerate}

Хорошим вариантом комбинации двух идей, описанных выше, является запускать почти всегда mark-sweep, а когда аллокатор начинает тормозить, то есть фрагментация памяти становится ощутимой, запускать mark-compact. Ключевая идея здесь в том, что mark-compact не имеет смысла запускать через небольшие промежутки времени, так как память не успевает фрагментироваться.

\subsubsection{Копирующий сборщик мусора (Copying GC)}
Этот сборщик мусора также спроектирован для решения проблемы фрагментации памяти.
В начале вся Heap делится на две равные части:
\begin{enumerate}[label=\arabic*.]
    \item From-space. Область памяти в которой находятся все объекты.
    \item To-space. Пустая область, в которую будут копироваться объекты.
\end{enumerate}
Аллокации происходят очень быстро: в to-space на последнем байте установлен free pointer, с помощью сдвига free pointer на нужное кол-во байт происходит аллокация, если места не хватает, то части меняются местами и происходит копирование живых объектов из from-space в to-space. Притом после такого копирования решается проблема фрагментации.

\textbf{Преимущества}
\begin{enumerate}[label=\arabic*.]
    \item Сохраняются преимущества mark-compact, но аллокация быстрее.
    \item Collect быстрее чем у mark-compact, так как требует 1 проход по Heap.
    \item этот GC удобнее применять в связке с Generational GC, Parallel GC, чем mark-compact
    \item Фрагментации получается избегать полностью.
\end{enumerate}
\pagebreak

\textbf{Недостатки:}
\begin{enumerate}[label=\arabic*.]
    \item Главный недостаток -- уменьшение размера Heap в два раза.
    \item Сохраняются недостатки 1, 3, 4, 6 mark-compact
\end{enumerate}


\subsubsection{Поколенческий сборщик мусора (Generational GC)}

Было замечено, что \textbf{большинство объектов в программах «живут» недолго}. На основе этого наблюдения появилась идея \textbf{поколенческого GC}.

Этот GC делит память на \textbf{несколько зон (поколений)}:
\begin{enumerate}[label=\arabic*.]
    \item \textbf{Молодое поколение (Young Generation)} — недавно созданные объекты. Они очищаются чаще всего.
    \item \textbf{Среднее поколение (Survivor Generation)} — объекты, пережившие одну или несколько сборок.
    \item \textbf{Старое поколение (Old Generation)} — долгоживущие объекты, которые очищаются реже.
\end{enumerate}

\textbf{Преимущества:}
\begin{enumerate}[label=\arabic*.]
    \item Более эффективная очистка памяти: короткоживущие объекты удаляются быстро.
    \item Уменьшается время пауз GC.
\end{enumerate}

\textbf{Недостатки:}
\begin{enumerate}[label=\arabic*.]
    \item Надо поддерживать время жизни объектов, а также выполнять их перераспределение между поколениями
\end{enumerate}


\subsubsection{Конкурентный сборщик мусора (Concurrent GC)}

Традиционные GC требуют остановки программы на время работы, но в многопоточных приложениях такие паузы недопустимы. Решением стала идея \textbf{конкурентного GC (Concurrent GC)}, который выполняет сборку мусора \textbf{параллельно с выполнением кода}.

\textbf{Преимущества:}
\begin{enumerate}[label=\arabic*.]
    \item Минимальные задержки (low latency).
    \item Подходит для высоконагруженных систем, абсолютно необходимое решение для real-time систем.
\end{enumerate}

\textbf{Недостатки:}
\begin{enumerate}[label=\arabic*.]
    \item Тяжелее реализация и поддержка.
    \item Больше расходуется CPU time.
\end{enumerate}

\subsection{Сборка мусора в популярных языках программирования}

\subsubsection{CPython (Python)}
\begin{itemize}
    \item Использует \textbf{Reference Counting} как основной механизм.
    \item Для циклических ссылок применяется \textbf{Generational GC}, разделяющий объекты на три поколения.~\cite{pythonoverview}
\end{itemize}

\subsubsection{C\# (.NET)}
\begin{itemize}
    \item Основной механизм — \textbf{Generational GC} с Mark-Compact.
    \item Поддерживает \textbf{конкурентные режимы} GC для серверных приложений.~\cite{clrgc}
\end{itemize}

\subsubsection{Java (JVM)}
\begin{itemize}
    \item Использует комбинацию \textbf{Generational GC} и разных алгоритмов (Serial, Parallel, G1 GC, ZGC~\cite{oraclegc}).
    \item Поддерживает low latency GC (Shenandoah~\cite{shenandoahoverview}, ZGC) для минимизации пауз.
\end{itemize}

\subsubsection{Go}
\begin{itemize}
    \item Concurrent Mark-Sweep~\cite{gogcguide}
\end{itemize}

