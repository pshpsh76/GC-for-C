\section{Архитектура и реализация сборщика мусора}

\subsection{Общая архитектура}

Разрабатываемый сборщик мусора представляет собой систему автоматического уп\-равления памятью, реализованную как самостоятельная библиотека на языке C++ с внешним C-интерфейсом. Система предназначена для интеграции в рантайм C-программ, где традиционно отсутствует автоматическое управление памятью.

Архитектура библиотеки построена с разделением на три независимых компонента:
\begin{itemize}
    \item \textbf{GCImpl} — отвечает за внутреннюю реализацию сборки мусора, включая аллокацию, управление корнями, фазу маркировки и удаления.
    \item \textbf{GCScheduler} — реализует автоматический запуск сборки на основе внешних параметров.
    \item \textbf{GCPacer} — модуль анализа интенсивности выделения памяти, принимает решение о необходимости сборки.
\end{itemize}

Такое разбиение реализовано с целью масштабируемости и дальнейшей расширяемости: каждая из частей может быть модифицирована или заменена независимо. Например, можно легко внедрить другой алгоритм (например, Generational GC) без необходимости переписывать логику планирования или сбора статистики. Благодаря модульной архитектуре возможно проводить точечные оптимизации, не нарушая остальную логику.

\subsection{Выбор стратегии сборки: Mark-Sweep}

В качестве основного алгоритма сборки выбран классический \textbf{Mark-Sweep}. Основные причины этого выбора:

\begin{itemize}
    \item \textbf{Простота реализации.} Алгоритм не требует перемещения объектов, не нуждается в обновлении указателей, не зависит от структуры типов и может быть реализован полностью на уровне пользовательского кода без поддержки со стороны компилятора.
    \item \textbf{Эффективность в реальных сценариях.} Для большинства программ, особенно в ручных системах управления памятью, Mark-Sweep демонстрирует предсказуемое поведение и малый оверхед в паузах.
    \item \textbf{Поддержка модификаций.} На основе Mark-Sweep легко реализовать улучшенные версии, включая Mark-Compact, Incremental GC, Generational GC и др. Выбор данного алгоритма позволяет сохранить гибкость дальнейшего развития проекта.
    \item \textbf{Совместимость с языком C++.} Использование C++ позволило реализовать безопасную и быструю работу с памятью, используя RAII и STL-контейнеры, при этом оставаясь независимым от высокоуровневых механизмов языков с JIT или встроенным GC.
\end{itemize}

\subsection{Жизненный цикл аллокации}

Пользователь взаимодействует с системой через функции:
\begin{itemize}
    \item \texttt{gc\_malloc}, \texttt{gc\_calloc}, \texttt{gc\_realloc}, \texttt{gc\_free} — аналоги стандартных функций.
    \item Все объекты автоматически регистрируются в GC с помощью метода \\\texttt{CreateAllocation}, где сохраняется указатель, размер, финализатор и внутренний «временной маркер» \texttt{timer\_}.
\end{itemize}

Удаление объектов возможно как вручную (через \texttt{gc\_free}), так и автоматически в ходе сборки мусора.

\subsection{Стратегия сборки: Stop-the-World}

Реализация использует модель \textbf{Stop-the-World} при сборке мусора. Это означает, что во время выполнения фазы сборки (маркировки и удаления) все пользовательские потоки временно приостанавливаются. Данный подход выбран по следующим причинам:

\begin{itemize}
    \item \textbf{Суммарная экономия CPU ресурсов.} В отличие от конкурентных GC, которые требуют введения write barriers (барьеров записи) и постоянного мониторинга изменений в памяти, Stop-the-World позволяет проводить сборку полностью в одном потоке без дополнительных оверхедов. Это объясняется тем, что большая часть действий с памятью в реальных программах -- чтение и запись, а не аллокация, деаллокация.
    \item \textbf{Простота реализации и отладки.} Модель с полной остановкой потоков упрощает синхронизацию и избегает сложных состояний гонки, характерных для параллельных и инкрементальных GC.
    \item \textbf{Надёжность.} Все изменения в памяти происходят в контролируемом режиме, что делает систему более устойчивой и предсказуемой, а также более удобной для последующих изменений.
\end{itemize}

На практике, несмотря на паузы, Stop-the-World GC часто оказывается быстрее и стабильнее в типичных сценариях, особенно при наличии короткоживущих объектов и небольших heap'ов.

\subsection{Управление корнями}

GC работает на основе понятия \textbf{GC-Root} — это участок памяти, в котором могут находиться указатели на управляемые объекты. Пользователь обязан явно регистрировать такие области через функции \texttt{gc\_add\_root} и \texttt{gc\_delete\_root} либо при инициализации \texttt{gc\_init}. Это позволяет сборщику точно знать, где искать активные ссылки.

\subsection{Автоматическая сборка и автонастройка}

В системе реализован адаптивный механизм триггера сборки мусора. Компонент \\\texttt{GCPacer} отслеживает:
\begin{itemize}
    \item количество выделенных байтов и число аллокаций;
    \item скорость выделения памяти (мгновенное и сглаженное значения).
\end{itemize}

На основе этих данных \texttt{GCScheduler} принимает решение о запуске сборки. Сборка может быть вызвана, если:
\begin{itemize}
    \item превышен порог по аллокациям/байтам;
    \item обнаружен пик активности (например, резкое увеличение аллокаций).
\end{itemize}
Все пороги можно узнать и поменять с помощью предоставленного api, также можно отключить автоматическую сборку и очищать память только посредством вызова \texttt{gc\_collect}
\subsection{Параллельность и многопоточность}

Сборщик реализует безопасную поддержку многопоточности. Для этого:
\begin{itemize}
    \item Каждый поток, использующий GC, должен быть явно зарегистрирован с помощью функции \\\texttt{gc\_register\_thread}, а при завершении — удалён через \texttt{gc\_deregister\_thread}.
    \item Во время сборки выполняется механизм \textbf{Stop-the-World}, при котором активные потоки приостанавливаются с помощью условной переменной, и GC может безопасно выполнять обход и очистку памяти.
    \item Потоки обязаны периодически вызывать функцию \texttt{gc\_safepoint()} — специальную контрольную точку. Она может вызываться в произвольных местах кода. Если поток ни разу не вызовет safepoint, сборщик не сможет приостановить выполнение и, соответственно, не сможет начать сборку мусора.
    \item Используются мьютексы и атомарные переменные для синхронизации потоков и корректного завершения фазы сборки.
\end{itemize}

Также реализована маркировка в виде параллельного обхода объектов с помощью очередей со стилем work-stealing — это позволяет эффективно масштабироваться при большом количестве потоков. Но данный механизм маркировки не выбран основным, так как имеет большую деградацию в производительности на большом количестве gc roots, на маленьком количестве потоков, а также на маленьком количестве памяти.

\subsection{Интерфейс и интеграция}

Библиотека предоставляет полноценный C-интерфейс, не требующий использования классов. Это позволяет легко интегрировать сборщик в низкоуровневые проекты на C и C++. Кроме того, предусмотрены функции управления поведением GC в рантайме: включение/отключение автоматической сборки, установка порогов и интервалов.

\subsection{Объёмные характеристики}

\begin{itemize}
    \item Объём кода: $\sim$2000 строк.
    \item Число тестов: более 20 модульных и многопоточных тестов.
    \item Присутствуют 5 сценариев бенчмарк тестирования, один из которых - симуляция работы с памятью, одновременно и стресс тестирование.
    \item Поддерживаемые режимы: ручной GC, автоматический GC с автонастройкой, многопоточный обход.
\end{itemize}
